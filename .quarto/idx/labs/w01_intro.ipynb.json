{"title":"Introduction & Python Refresher","markdown":{"yaml":{"title":"Introduction & Python Refresher","author":"Gabriele Filomena","date":"today","format":{"html":{"code-fold":false}}},"headingText":"Part I: Powerful Web Mapping Examples","containsRefs":false,"markdown":"\n\nThe **Lecture slides** can be found [here](https://slides.com/gfilo/web-mapping-and-geovisualisation-envs456/fullscreen).\n\nThis **lab**'s notebook can be downloaded from [here](https://github.com/GDSL-UL/wma/blob/main/labs/w01_intro.ipynb).\n\n\nThis part of the lab has two main components:\n1.  The first one will require you to find a partner and work together with her/him\n2.  And the second one will involve group discussion.\n\n### Paired Activity\n\nIn pairs, find **three** examples where web maps are used to communicate an idea. Complete the following sheet for each example:\n\n-   **Substantive**\n    -   `Title`: Title of the map/project\n    -   `Author`: Who is behind the project?\n    -   `Big idea`: a \"one-liner\" on what the project tries to accomplish --\n    -   `Message`: what does the map try to get accross\n\n-   **Technical**\n    -   `URL`:\n    -   `Interactivity`: does the map let you interact with it in any way? Yes/No\n    -   `Zoomable`: can you explore the map at different scales? Yes/No\n    -   `Tooltips`:\n    -   `Basemap`: Is there an underlying map providing geographical context? Yes/No. If so, who is it provided by?\n    -   `Technology`: can you guess what technology does this map rely on?\n\nPost each sheet as a separate item on the Teams channel for Lab No.1\n\n#### Example\nThe project \"WHO Coronavirus (COVID-19) Dashboard\"\n\n<img src=\"../labs_img/who_covid.png\" width = 70%/>\n\n-   **Substantive**\n\n    -   `Title`: WHO Coronavirus (COVID-19) Dashboard\n    -   `Author`: World Health Organization\n    -   `Big idea`: Shows confirmed COVID-19 cases and deaths by country to date\n    -   `Message`: The project displays a map of the world where COVID-19 cases are shown by country. This element is used to show which countries have had more cases (large trends). A drop down button allows us to visualise the map by a) Total per 100,000 population b) % change in the last 7 days c) newly reported in the last 7 days d) newly reported in the last 24 hours.\n\n-   **Technical**\n  \n    -   `URL`: [`https://covid19.who.int/`](https://covid19.who.int/)\n    -   `Interactivity`: Yes\n    -   `Zoomable`: Yes\n    -   `Tooltips`: Yes\n    -   `Basemap`: No\n    -   `Technology`: Unknown\n\nHere are a couple of other COVID-19 examples of web-maps that where basemaps and technology is easier to spot.\n\n-   [\"London School of Hygiene & Tropical Medicine - COVID-19 tracker\"](https://vac-lshtm.shinyapps.io/ncov_tracker/?_ga=2.246644480.501918083.1674819300-1251881958.1674819300)\n-   [\"Tracking Coronavirus in the United Kingdom: Latest Map and Case Count\"](https://www.nytimes.com/interactive/2021/world/united-kingdom-covid-cases.html)\n\n### Class discussion\n\nWe will select a few examples posted and collectively discuss (some of) the following questions:\n\n1.  What makes them powerful, what \"speaks\" to us?\n2.  What could be improved, what is counter-intuitive?\n3.  What design elements do they rely on?\n4.  What technology do they use?\n\n### References\n\n-   For an excellent coverage of \"visualisation literacy\", Chapter 11 of Andy Kirk's [\"Data Visualisation\"](https://www.visualisingdata.com/book/) is a great start. Lab: Getting up to speed for web mapping\n-   A comprehensive overview of computational notebooks and how they relate to modern scientific work is available on [Ch.1 of the GDS book](https://geographicdata.science/book/notebooks/01_geo_thinking.html).\n-   A recent overview of notebooks in Geography is available in [Boeing & Arribas-Bel (2021)](https://gistbok.ucgis.org/bok-topics/gis-and-computational-notebooks)\n\n## Part II: Python/Pandas (Refresher)\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/gboeing/ppd599/tree/main).\nCopyright (c) 2013-2023 Geoff Boeing.*\n\n### Python\n\nA quick overview of ubiquitous programming concepts including data types, for loops, if-then-else conditionals, and functions.\n\n### `pandas` Series and DataFrames\n\n[pandas](https://pandas.pydata.org/) has two primary data structures we will work with: `Series` and `DataFrame`.\n\n#### Pandas Series\n\n#### Pandas DataFrames\n\n### Loading data in Pandas\n\nUsually, you'll work with data by loading a dataset file into pandas. CSV is the most common format. But pandas can also ingest tab-separated data, JSON, and proprietary file formats like Excel .xlsx files, Stata, SAS, and SPSS.\n\nBelow, notice what pandas's `read_csv` function does:\n\n1. Recognize the header row and get its variable names.\n1. Read all the rows and construct a pandas DataFrame (an assembly of pandas Series rows and columns).\n1. Construct a unique index, beginning with zero.\n1. Infer the data type of each variable (i.e., column).\n\n### Selecting and slicing data from a DataFrame\n\n#### Select DataFrame's column(s) by name\n\n#### Select row(s) by label\n\n#### Select by (integer) position - Independent from actual Index\n\n#### Select/filter by value\n\nYou can subset or filter a dataframe for based on the values in its rows/columns.\n\n### Grouping and summarizing\n\n### Indexes\n\nEach `DataFrame` has an index. Indexes do not have to be unique (but that would be for the best)\n\n## Part III: Geospatial Vector data in Python\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/jorisvandenbossche/geopandas-tutorial).\nCopyright (c) 2018, Joris Van den Bossche.*\n\n### Importing geospatial data\n\nGeoPandas builds on Pandas types `Series` and `Dataframe`, by incorporating information about geographical space.\n\n- `GeoSeries`: a Series object designed to store shapely geometry object\n- `GeoDataFrame`: object is a pandas DataFrame that has a column with geometry (that contains a *Geoseries*)\n\nWe can use the GeoPandas library to read many of GIS file formats (relying on the `fiona` library under the hood, which is an interface to GDAL/OGR), using the `gpd.read_file` function. For example, let's start by reading a shapefile with all the countries of the world (adapted from http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-admin-0-countries/, zip file is available in the `/data` directory), and inspect the data:\n\nWe observe that:\n\n- Using `.head()` we can see the first rows of the dataset, just like we can do with Pandas.\n- There is a `geometry` column and the different countries are represented as polygons\n- We can use the `.plot()` (matplotlib) method to quickly get a *basic* visualization of the data\n\n### What's a GeoDataFrame?\n\nWe used the GeoPandas library to read in the geospatial data, and this returned us a `GeoDataFrame`:\n\nA GeoDataFrame contains a tabular, geospatial dataset:\n\n* It has a 'geometry' column that holds the geometry information (or features in GeoJSON).\n* The other columns are the **attributes** (or properties in GeoJSON) that describe each of the geometries.\n\nSuch a `GeoDataFrame` is just like a pandas `DataFrame`, but with some additional functionality for working with geospatial data:\n* A `geometry` attribute that always returns the column with the geometry information (returning a `GeoSeries`). The column name itself does not necessarily need to be 'geometry', but it will always be accessible as the `geometry` attribute.\n* It has some extra methods for working with spatial data (area, distance, buffer, intersection, ...) [see here, for example](https://github.com/jorisvandenbossche/geopandas-tutorial/blob/main/04-spatial-operations-overlays.ipynb).\n\nIt's still a `DataFrame`, so we have all the `pandas` functionality available to use on the geospatial dataset, and to do data manipulations with the attributes and geometry information together. For example, we can calculate the average population over all countries (by accessing the 'pop_est' column, and calling the `mean` method on it):\n\nThe rest of the tutorial is going to assume you already know some pandas basics, but we will try to give hints for that part for those that are not familiar.\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important:** <br>\n\n* A `GeoDataFrame` allows to perform typical tabular data analysis together with spatial operations\n* A `GeoDataFrame` (or *Feature Collection*) consists of:\n    * **Geometries** or **features**: the spatial objects\n    * **Attributes** or **properties**: columns with information about each spatial object\n\n</div>\n\n### Geometries: Points, Linestrings and Polygons\n\nSpatial **vector** data can consist of different types, and the 3 fundamental types are:\n\n<img src=\"../labs_img/simple_features_3_text.svg\" width=\"70%\">\n\n* **Point** data: represents a single point in space.\n* **Line** data (\"LineString\"): represented as a sequence of points that form a line.\n* **Polygon** data: represents a filled area.\n\nAnd each of them can also be combined in multi-part geometries (See https://shapely.readthedocs.io/en/stable/manual.html#geometric-objects for extensive overview).\n\nFor the example we have seen up to now, the individual geometry objects are Polygons:\n\nLet's import some other datasets with different types of geometry objects.\n\nA dateset about cities in the world (adapted from http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-populated-places/, zip file is available in the `/data` directory), consisting of `Point` data:\n\nAnd a dataset of rivers in the world (from http://www.naturalearthdata.com/downloads/50m-physical-vectors/50m-rivers-lake-centerlines/, zip file is available in the `/data` directory) where each river is a `(Multi-)LineString`:\n\n### The `shapely` library\n\nThe individual geometry objects are provided by the [`shapely`](https://shapely.readthedocs.io/en/stable/) library\n\nTo construct one ourselves:\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\nSingle geometries are represented by `shapely` objects:\n\n* If you access a single geometry of a GeoDataFrame, you get a shapely geometry object\n* Those objects have similar functionality as geopandas objects (GeoDataFrame/GeoSeries). For example:\n    * `single_shapely_object.distance(other_point)` -> distance between two points\n    * `geodataframe.distance(other_point)` ->  distance for each point in the geodataframe to the other point\n\n</div>\n\n### Plotting\n\n### Creating GeoDataFrames (withouth specifying the CRS)\n\n# Practice\n\nThroughout the exercises in this course, we will work with several datasets about the city of Paris.\n\nHere, we start with the following datasets:\n\n- The administrative districts of Paris (https://opendata.paris.fr/explore/dataset/quartier_paris/): `paris_districts_utm.geojson`\n- Real-time (at the moment I downloaded them ..) information about the public bicycle sharing system in Paris (vélib, https://opendata.paris.fr/explore/dataset/stations-velib-disponibilites-en-temps-reel/information/): `data/paris_bike_stations_mercator.gpkg`\n\nBoth datasets are provided as spatial datasets using a GIS file format.\n\n<div class=\"alert alert-success\">\n\n**Excercise 1**:\n\nWe will start by exploring the bicycle station dataset (available as a GeoPackage file: `data/paris_bike_stations_mercator.gpkg`)\n    \n* Read the stations datasets into a GeoDataFrame called `stations`.\n* Check the type of the returned object\n* Check the first rows of the dataframes. What kind of geometries does this datasets contain?\n* How many features are there in the dataset? \n    \n<details><summary>Hints</summary>\n\n* Use `type(..)` to check any Python object type\n* The `gpd.read_file()` function can read different geospatial file formats. You pass the file name as first argument.\n* Use the `.shape` attribute to get the number of features\n\n</details>\n    \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 2**:\n\n* Make a quick plot of the `stations` dataset.\n* Make the plot a bit larger by setting the figure size to (12, 6) (hint: the `plot` method accepts a `figsize` keyword).\n \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 3**:\n\nNext, we will explore the dataset on the administrative districts of Paris (available as a GeoJSON file: `../data/paris_districts_utm.geojson`)\n\n* Read the dataset into a GeoDataFrame called `districts`.\n* Check the first rows of the dataframe. What kind of geometries does this dataset contain?\n* How many features are there in the dataset? (hint: use the `.shape` attribute)\n* Make a quick plot of the `districts` dataset (set the figure size to (12, 6)).\n    \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 4**:\n    \nWhat are the largest districts (biggest area)?\n\n* Calculate the area of each district.\n* Add this area as a new column to the `districts` dataframe.\n* Sort the dataframe by the area column from largest to smallest values (descending).\n\n<details><summary>Hints</summary>\n\n* Adding a column can be done by assigning values to a column using the same square brackets syntax: `df['new_col'] = values`\n* To sort the rows of a DataFrame, use the `sort_values()` method, specifying the colum to sort on with the `by='col_name'` keyword. Check the help of this method to see how to sort ascending or descending.\n\n</details>\n\n</div>\n\n## Part IV: Coordinate reference systems & Projections\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/jorisvandenbossche/geopandas-tutorial).\nCopyright (c) 2018, Joris Van den Bossche.*\n\n### Coordinate reference systems\n\nUp to now, we have used the geometry data with certain coordinates without further wondering what those coordinates mean or how they are expressed.\n\n> The **Coordinate Reference System (CRS)** relates the coordinates to a specific location on earth.\n\nFor an in-depth explanation, see https://docs.qgis.org/2.8/en/docs/gentle_gis_introduction/coordinate_reference_systems.html\n\n#### Geographic coordinates\n\n> Degrees of latitude and longitude.\n>\n> E.g. 48°51′N, 2°17′E\n\nThe most known type of coordinates are geographic coordinates: we define a position on the globe in degrees of latitude and longitude, relative to the equator and the prime meridian. \nWith this system, we can easily specify any location on earth. It is used widely, for example in GPS. If you inspect the coordinates of a location in Google Maps, you will also see latitude and longitude.\n\n**Attention!**\n\nin Python we use (lon, lat) and not (lat, lon)\n\n- Longitude: [-180, 180]{{1}}\n- Latitude: [-90, 90]{{1}}\n\n### Projected coordinates\n\n> `(x, y)` coordinates are usually in meters or feet\n\nAlthough the earth is a globe, in practice we usually represent it on a flat surface: think about a physical map, or the figures we have made with Python on our computer screen.\nGoing from the globe to a flat map is what we call a *projection*.\n\n<img src=\"../labs_img/projection.png\" width = 70%>\n\nWe project the surface of the earth onto a 2D plane so we can express locations in cartesian x and y coordinates, on a flat surface. In this plane, we then typically work with a length unit such as meters instead of degrees, which makes the analysis more convenient and effective.\n\nHowever, there is an important remark: the 3 dimensional earth can never be represented perfectly on a 2 dimensional map, so projections inevitably introduce distortions. To minimize such errors, there are different approaches to project, each with specific advantages and disadvantages.\n\nSome projection systems will try to preserve the area size of geometries, such as the Albers Equal Area projection. Other projection systems try to preserve angles, such as the Mercator projection, but will see big distortions in the area. Every projection system will always have some distortion of area, angle or distance.\n\n<table><tr>\n<td> <img src=\"../labs_img/projections-AlbersEqualArea.png\"> </td>\n<td> <img src=\"../labs_img/projections-Mercator.png\"> </td>\n</tr>\n<tr>\n<td> <img src=\"../labs_img/projections-Robinson.png\"> </td>\n</tr></table>\n\n**Projected size vs actual size (Mercator projection)**:\n<img src=\"../labs_img/mercator_projection_area.gif\">\n\n### Coordinate Reference Systems in Python / GeoPandas\n\nA GeoDataFrame or GeoSeries has a `.crs` attribute which holds (optionally) a description of the coordinate reference system of the geometries:\n\nFor the `countries` dataframe, it indicates that it uses the EPSG 4326 / WGS84 lon/lat reference system, which is one of the most used for geographic coordinates.\n\n\nIt uses coordinates as latitude and longitude in degrees, as can you be seen from the x/y labels on the plot:\n\nThe `.crs` attribute returns a `pyproj.CRS` object. To specify a CRS, we typically use some string representation:\n\n- **EPSG code**\n  Example: `EPSG:4326` = WGS84 geographic CRS (longitude, latitude)\n  \nFor more information, see also http://geopandas.readthedocs.io/en/latest/projections.html.\n\n#### Transforming to another CRS\n\nWe can convert a GeoDataFrame to another reference system using the `to_crs` function. \n\nFor example, let's convert the countries to the World Mercator projection (http://epsg.io/3395):\n\nNote the different scale of x and y.\n\n#### Why using a different CRS?\n\nThere are sometimes good reasons you want to change the coordinate references system of your dataset, for example:\n\n- Different sources with different CRS -> need to convert to the same crs.   \n- Different countries/geographical areas with different CRS.\n- Mapping (distortion of shape and distances).\n- Distance / area based calculations -> ensure you use an appropriate projected coordinate system expressed in a meaningful unit such as meters or feet (**not degrees!**).\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important:**\n\nAll the calculations (e.g. distance, spatial operations, etc.) that take place in `GeoPandas` and `Shapely` assume that your data is represented in a 2D cartesian plane, and thus the result of those calculations will only be correct if your data is properly projected.\n\n</div>\n\n## Practice\n\nAgain, we will go back to the Paris datasets. Up to now, we provided the datasets in an appropriate projected CRS for the exercises. But the original data were actually using geographic coordinates. In the following exercises, we will start from there.\n\nGoing back to the Paris districts dataset, this is now provided as a GeoJSON file (`\"../data/paris_districts.geojson\"`) in geographic coordinates.\n\nFor converting the layer to projected coordinates, we will use the standard projected CRS for France is the RGF93 / Lambert-93 reference system, referenced by the `EPSG:2154` number.\n\n<div class=\"alert alert-success\">\n\n**Exercise: Projecting a GeoDataFrame**\n\n* Read the districts datasets (`../data/paris_districts.geojson\"`) into a GeoDataFrame called `districts`.\n* Look at the CRS attribute of the GeoDataFrame. Do you recognize the EPSG number?\n* Make a plot of the `districts` dataset.\n* Calculate the area of all districts.\n* Convert the `districts` to a projected CRS (using the `EPSG:2154` for France). Call the new dataset `districts_RGF93`.\n* Make a similar plot of `districts_RGF93`.\n* Calculate the area of all districts again with `districts_RGF93` (the result will now be expressed in m²).\n    \n    \n<details><summary>Hints</summary>\n\n* The CRS information is stored in the `.crs` attribute of a GeoDataFrame.\n* Making a simple plot of a GeoDataFrame can be done with the `.plot()` method.\n* Converting to a different CRS can be done with the `.to_crs()` method, and the CRS can be specified as an EPSG number using the `epsg` keyword.\n\n</details>\n\n</div>\n","srcMarkdownNoYaml":"\n\nThe **Lecture slides** can be found [here](https://slides.com/gfilo/web-mapping-and-geovisualisation-envs456/fullscreen).\n\nThis **lab**'s notebook can be downloaded from [here](https://github.com/GDSL-UL/wma/blob/main/labs/w01_intro.ipynb).\n\n## Part I: Powerful Web Mapping Examples\n\nThis part of the lab has two main components:\n1.  The first one will require you to find a partner and work together with her/him\n2.  And the second one will involve group discussion.\n\n### Paired Activity\n\nIn pairs, find **three** examples where web maps are used to communicate an idea. Complete the following sheet for each example:\n\n-   **Substantive**\n    -   `Title`: Title of the map/project\n    -   `Author`: Who is behind the project?\n    -   `Big idea`: a \"one-liner\" on what the project tries to accomplish --\n    -   `Message`: what does the map try to get accross\n\n-   **Technical**\n    -   `URL`:\n    -   `Interactivity`: does the map let you interact with it in any way? Yes/No\n    -   `Zoomable`: can you explore the map at different scales? Yes/No\n    -   `Tooltips`:\n    -   `Basemap`: Is there an underlying map providing geographical context? Yes/No. If so, who is it provided by?\n    -   `Technology`: can you guess what technology does this map rely on?\n\nPost each sheet as a separate item on the Teams channel for Lab No.1\n\n#### Example\nThe project \"WHO Coronavirus (COVID-19) Dashboard\"\n\n<img src=\"../labs_img/who_covid.png\" width = 70%/>\n\n-   **Substantive**\n\n    -   `Title`: WHO Coronavirus (COVID-19) Dashboard\n    -   `Author`: World Health Organization\n    -   `Big idea`: Shows confirmed COVID-19 cases and deaths by country to date\n    -   `Message`: The project displays a map of the world where COVID-19 cases are shown by country. This element is used to show which countries have had more cases (large trends). A drop down button allows us to visualise the map by a) Total per 100,000 population b) % change in the last 7 days c) newly reported in the last 7 days d) newly reported in the last 24 hours.\n\n-   **Technical**\n  \n    -   `URL`: [`https://covid19.who.int/`](https://covid19.who.int/)\n    -   `Interactivity`: Yes\n    -   `Zoomable`: Yes\n    -   `Tooltips`: Yes\n    -   `Basemap`: No\n    -   `Technology`: Unknown\n\nHere are a couple of other COVID-19 examples of web-maps that where basemaps and technology is easier to spot.\n\n-   [\"London School of Hygiene & Tropical Medicine - COVID-19 tracker\"](https://vac-lshtm.shinyapps.io/ncov_tracker/?_ga=2.246644480.501918083.1674819300-1251881958.1674819300)\n-   [\"Tracking Coronavirus in the United Kingdom: Latest Map and Case Count\"](https://www.nytimes.com/interactive/2021/world/united-kingdom-covid-cases.html)\n\n### Class discussion\n\nWe will select a few examples posted and collectively discuss (some of) the following questions:\n\n1.  What makes them powerful, what \"speaks\" to us?\n2.  What could be improved, what is counter-intuitive?\n3.  What design elements do they rely on?\n4.  What technology do they use?\n\n### References\n\n-   For an excellent coverage of \"visualisation literacy\", Chapter 11 of Andy Kirk's [\"Data Visualisation\"](https://www.visualisingdata.com/book/) is a great start. Lab: Getting up to speed for web mapping\n-   A comprehensive overview of computational notebooks and how they relate to modern scientific work is available on [Ch.1 of the GDS book](https://geographicdata.science/book/notebooks/01_geo_thinking.html).\n-   A recent overview of notebooks in Geography is available in [Boeing & Arribas-Bel (2021)](https://gistbok.ucgis.org/bok-topics/gis-and-computational-notebooks)\n\n## Part II: Python/Pandas (Refresher)\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/gboeing/ppd599/tree/main).\nCopyright (c) 2013-2023 Geoff Boeing.*\n\n### Python\n\nA quick overview of ubiquitous programming concepts including data types, for loops, if-then-else conditionals, and functions.\n\n### `pandas` Series and DataFrames\n\n[pandas](https://pandas.pydata.org/) has two primary data structures we will work with: `Series` and `DataFrame`.\n\n#### Pandas Series\n\n#### Pandas DataFrames\n\n### Loading data in Pandas\n\nUsually, you'll work with data by loading a dataset file into pandas. CSV is the most common format. But pandas can also ingest tab-separated data, JSON, and proprietary file formats like Excel .xlsx files, Stata, SAS, and SPSS.\n\nBelow, notice what pandas's `read_csv` function does:\n\n1. Recognize the header row and get its variable names.\n1. Read all the rows and construct a pandas DataFrame (an assembly of pandas Series rows and columns).\n1. Construct a unique index, beginning with zero.\n1. Infer the data type of each variable (i.e., column).\n\n### Selecting and slicing data from a DataFrame\n\n#### Select DataFrame's column(s) by name\n\n#### Select row(s) by label\n\n#### Select by (integer) position - Independent from actual Index\n\n#### Select/filter by value\n\nYou can subset or filter a dataframe for based on the values in its rows/columns.\n\n### Grouping and summarizing\n\n### Indexes\n\nEach `DataFrame` has an index. Indexes do not have to be unique (but that would be for the best)\n\n## Part III: Geospatial Vector data in Python\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/jorisvandenbossche/geopandas-tutorial).\nCopyright (c) 2018, Joris Van den Bossche.*\n\n### Importing geospatial data\n\nGeoPandas builds on Pandas types `Series` and `Dataframe`, by incorporating information about geographical space.\n\n- `GeoSeries`: a Series object designed to store shapely geometry object\n- `GeoDataFrame`: object is a pandas DataFrame that has a column with geometry (that contains a *Geoseries*)\n\nWe can use the GeoPandas library to read many of GIS file formats (relying on the `fiona` library under the hood, which is an interface to GDAL/OGR), using the `gpd.read_file` function. For example, let's start by reading a shapefile with all the countries of the world (adapted from http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-admin-0-countries/, zip file is available in the `/data` directory), and inspect the data:\n\nWe observe that:\n\n- Using `.head()` we can see the first rows of the dataset, just like we can do with Pandas.\n- There is a `geometry` column and the different countries are represented as polygons\n- We can use the `.plot()` (matplotlib) method to quickly get a *basic* visualization of the data\n\n### What's a GeoDataFrame?\n\nWe used the GeoPandas library to read in the geospatial data, and this returned us a `GeoDataFrame`:\n\nA GeoDataFrame contains a tabular, geospatial dataset:\n\n* It has a 'geometry' column that holds the geometry information (or features in GeoJSON).\n* The other columns are the **attributes** (or properties in GeoJSON) that describe each of the geometries.\n\nSuch a `GeoDataFrame` is just like a pandas `DataFrame`, but with some additional functionality for working with geospatial data:\n* A `geometry` attribute that always returns the column with the geometry information (returning a `GeoSeries`). The column name itself does not necessarily need to be 'geometry', but it will always be accessible as the `geometry` attribute.\n* It has some extra methods for working with spatial data (area, distance, buffer, intersection, ...) [see here, for example](https://github.com/jorisvandenbossche/geopandas-tutorial/blob/main/04-spatial-operations-overlays.ipynb).\n\nIt's still a `DataFrame`, so we have all the `pandas` functionality available to use on the geospatial dataset, and to do data manipulations with the attributes and geometry information together. For example, we can calculate the average population over all countries (by accessing the 'pop_est' column, and calling the `mean` method on it):\n\nThe rest of the tutorial is going to assume you already know some pandas basics, but we will try to give hints for that part for those that are not familiar.\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important:** <br>\n\n* A `GeoDataFrame` allows to perform typical tabular data analysis together with spatial operations\n* A `GeoDataFrame` (or *Feature Collection*) consists of:\n    * **Geometries** or **features**: the spatial objects\n    * **Attributes** or **properties**: columns with information about each spatial object\n\n</div>\n\n### Geometries: Points, Linestrings and Polygons\n\nSpatial **vector** data can consist of different types, and the 3 fundamental types are:\n\n<img src=\"../labs_img/simple_features_3_text.svg\" width=\"70%\">\n\n* **Point** data: represents a single point in space.\n* **Line** data (\"LineString\"): represented as a sequence of points that form a line.\n* **Polygon** data: represents a filled area.\n\nAnd each of them can also be combined in multi-part geometries (See https://shapely.readthedocs.io/en/stable/manual.html#geometric-objects for extensive overview).\n\nFor the example we have seen up to now, the individual geometry objects are Polygons:\n\nLet's import some other datasets with different types of geometry objects.\n\nA dateset about cities in the world (adapted from http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-populated-places/, zip file is available in the `/data` directory), consisting of `Point` data:\n\nAnd a dataset of rivers in the world (from http://www.naturalearthdata.com/downloads/50m-physical-vectors/50m-rivers-lake-centerlines/, zip file is available in the `/data` directory) where each river is a `(Multi-)LineString`:\n\n### The `shapely` library\n\nThe individual geometry objects are provided by the [`shapely`](https://shapely.readthedocs.io/en/stable/) library\n\nTo construct one ourselves:\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\nSingle geometries are represented by `shapely` objects:\n\n* If you access a single geometry of a GeoDataFrame, you get a shapely geometry object\n* Those objects have similar functionality as geopandas objects (GeoDataFrame/GeoSeries). For example:\n    * `single_shapely_object.distance(other_point)` -> distance between two points\n    * `geodataframe.distance(other_point)` ->  distance for each point in the geodataframe to the other point\n\n</div>\n\n### Plotting\n\n### Creating GeoDataFrames (withouth specifying the CRS)\n\n# Practice\n\nThroughout the exercises in this course, we will work with several datasets about the city of Paris.\n\nHere, we start with the following datasets:\n\n- The administrative districts of Paris (https://opendata.paris.fr/explore/dataset/quartier_paris/): `paris_districts_utm.geojson`\n- Real-time (at the moment I downloaded them ..) information about the public bicycle sharing system in Paris (vélib, https://opendata.paris.fr/explore/dataset/stations-velib-disponibilites-en-temps-reel/information/): `data/paris_bike_stations_mercator.gpkg`\n\nBoth datasets are provided as spatial datasets using a GIS file format.\n\n<div class=\"alert alert-success\">\n\n**Excercise 1**:\n\nWe will start by exploring the bicycle station dataset (available as a GeoPackage file: `data/paris_bike_stations_mercator.gpkg`)\n    \n* Read the stations datasets into a GeoDataFrame called `stations`.\n* Check the type of the returned object\n* Check the first rows of the dataframes. What kind of geometries does this datasets contain?\n* How many features are there in the dataset? \n    \n<details><summary>Hints</summary>\n\n* Use `type(..)` to check any Python object type\n* The `gpd.read_file()` function can read different geospatial file formats. You pass the file name as first argument.\n* Use the `.shape` attribute to get the number of features\n\n</details>\n    \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 2**:\n\n* Make a quick plot of the `stations` dataset.\n* Make the plot a bit larger by setting the figure size to (12, 6) (hint: the `plot` method accepts a `figsize` keyword).\n \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 3**:\n\nNext, we will explore the dataset on the administrative districts of Paris (available as a GeoJSON file: `../data/paris_districts_utm.geojson`)\n\n* Read the dataset into a GeoDataFrame called `districts`.\n* Check the first rows of the dataframe. What kind of geometries does this dataset contain?\n* How many features are there in the dataset? (hint: use the `.shape` attribute)\n* Make a quick plot of the `districts` dataset (set the figure size to (12, 6)).\n    \n</div>\n\n<div class=\"alert alert-success\">\n\n**Exercise 4**:\n    \nWhat are the largest districts (biggest area)?\n\n* Calculate the area of each district.\n* Add this area as a new column to the `districts` dataframe.\n* Sort the dataframe by the area column from largest to smallest values (descending).\n\n<details><summary>Hints</summary>\n\n* Adding a column can be done by assigning values to a column using the same square brackets syntax: `df['new_col'] = values`\n* To sort the rows of a DataFrame, use the `sort_values()` method, specifying the colum to sort on with the `by='col_name'` keyword. Check the help of this method to see how to sort ascending or descending.\n\n</details>\n\n</div>\n\n## Part IV: Coordinate reference systems & Projections\n\n*Gabriele Filomena has prepared this notebook by readapting material shared on this [repository](https://github.com/jorisvandenbossche/geopandas-tutorial).\nCopyright (c) 2018, Joris Van den Bossche.*\n\n### Coordinate reference systems\n\nUp to now, we have used the geometry data with certain coordinates without further wondering what those coordinates mean or how they are expressed.\n\n> The **Coordinate Reference System (CRS)** relates the coordinates to a specific location on earth.\n\nFor an in-depth explanation, see https://docs.qgis.org/2.8/en/docs/gentle_gis_introduction/coordinate_reference_systems.html\n\n#### Geographic coordinates\n\n> Degrees of latitude and longitude.\n>\n> E.g. 48°51′N, 2°17′E\n\nThe most known type of coordinates are geographic coordinates: we define a position on the globe in degrees of latitude and longitude, relative to the equator and the prime meridian. \nWith this system, we can easily specify any location on earth. It is used widely, for example in GPS. If you inspect the coordinates of a location in Google Maps, you will also see latitude and longitude.\n\n**Attention!**\n\nin Python we use (lon, lat) and not (lat, lon)\n\n- Longitude: [-180, 180]{{1}}\n- Latitude: [-90, 90]{{1}}\n\n### Projected coordinates\n\n> `(x, y)` coordinates are usually in meters or feet\n\nAlthough the earth is a globe, in practice we usually represent it on a flat surface: think about a physical map, or the figures we have made with Python on our computer screen.\nGoing from the globe to a flat map is what we call a *projection*.\n\n<img src=\"../labs_img/projection.png\" width = 70%>\n\nWe project the surface of the earth onto a 2D plane so we can express locations in cartesian x and y coordinates, on a flat surface. In this plane, we then typically work with a length unit such as meters instead of degrees, which makes the analysis more convenient and effective.\n\nHowever, there is an important remark: the 3 dimensional earth can never be represented perfectly on a 2 dimensional map, so projections inevitably introduce distortions. To minimize such errors, there are different approaches to project, each with specific advantages and disadvantages.\n\nSome projection systems will try to preserve the area size of geometries, such as the Albers Equal Area projection. Other projection systems try to preserve angles, such as the Mercator projection, but will see big distortions in the area. Every projection system will always have some distortion of area, angle or distance.\n\n<table><tr>\n<td> <img src=\"../labs_img/projections-AlbersEqualArea.png\"> </td>\n<td> <img src=\"../labs_img/projections-Mercator.png\"> </td>\n</tr>\n<tr>\n<td> <img src=\"../labs_img/projections-Robinson.png\"> </td>\n</tr></table>\n\n**Projected size vs actual size (Mercator projection)**:\n<img src=\"../labs_img/mercator_projection_area.gif\">\n\n### Coordinate Reference Systems in Python / GeoPandas\n\nA GeoDataFrame or GeoSeries has a `.crs` attribute which holds (optionally) a description of the coordinate reference system of the geometries:\n\nFor the `countries` dataframe, it indicates that it uses the EPSG 4326 / WGS84 lon/lat reference system, which is one of the most used for geographic coordinates.\n\n\nIt uses coordinates as latitude and longitude in degrees, as can you be seen from the x/y labels on the plot:\n\nThe `.crs` attribute returns a `pyproj.CRS` object. To specify a CRS, we typically use some string representation:\n\n- **EPSG code**\n  Example: `EPSG:4326` = WGS84 geographic CRS (longitude, latitude)\n  \nFor more information, see also http://geopandas.readthedocs.io/en/latest/projections.html.\n\n#### Transforming to another CRS\n\nWe can convert a GeoDataFrame to another reference system using the `to_crs` function. \n\nFor example, let's convert the countries to the World Mercator projection (http://epsg.io/3395):\n\nNote the different scale of x and y.\n\n#### Why using a different CRS?\n\nThere are sometimes good reasons you want to change the coordinate references system of your dataset, for example:\n\n- Different sources with different CRS -> need to convert to the same crs.   \n- Different countries/geographical areas with different CRS.\n- Mapping (distortion of shape and distances).\n- Distance / area based calculations -> ensure you use an appropriate projected coordinate system expressed in a meaningful unit such as meters or feet (**not degrees!**).\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important:**\n\nAll the calculations (e.g. distance, spatial operations, etc.) that take place in `GeoPandas` and `Shapely` assume that your data is represented in a 2D cartesian plane, and thus the result of those calculations will only be correct if your data is properly projected.\n\n</div>\n\n## Practice\n\nAgain, we will go back to the Paris datasets. Up to now, we provided the datasets in an appropriate projected CRS for the exercises. But the original data were actually using geographic coordinates. In the following exercises, we will start from there.\n\nGoing back to the Paris districts dataset, this is now provided as a GeoJSON file (`\"../data/paris_districts.geojson\"`) in geographic coordinates.\n\nFor converting the layer to projected coordinates, we will use the standard projected CRS for France is the RGF93 / Lambert-93 reference system, referenced by the `EPSG:2154` number.\n\n<div class=\"alert alert-success\">\n\n**Exercise: Projecting a GeoDataFrame**\n\n* Read the districts datasets (`../data/paris_districts.geojson\"`) into a GeoDataFrame called `districts`.\n* Look at the CRS attribute of the GeoDataFrame. Do you recognize the EPSG number?\n* Make a plot of the `districts` dataset.\n* Calculate the area of all districts.\n* Convert the `districts` to a projected CRS (using the `EPSG:2154` for France). Call the new dataset `districts_RGF93`.\n* Make a similar plot of `districts_RGF93`.\n* Calculate the area of all districts again with `districts_RGF93` (the result will now be expressed in m²).\n    \n    \n<details><summary>Hints</summary>\n\n* The CRS information is stored in the `.crs` attribute of a GeoDataFrame.\n* Making a simple plot of a GeoDataFrame can be done with the `.plot()` method.\n* Converting to a different CRS can be done with the `.to_crs()` method, and the CRS can be specified as an EPSG number using the `epsg` keyword.\n\n</details>\n\n</div>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"w01_intro.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["../references.bib"],"editor":"visual","theme":"zephyr","title":"Introduction & Python Refresher","author":"Gabriele Filomena","date":"today"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"w01_intro.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Introduction & Python Refresher","author":"Gabriele Filomena","date":"today"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}